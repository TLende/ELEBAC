/*
 * Flash_driver.c
 *
 *  Created on: Feb 22, 2025
 *      Author: Thomas
 */
#include "main.h"
#include "EX_Global_Var.h"
#include "Flash_driver.h"
#include "Misc.h"

extern SPI_HandleTypeDef hspi1;

#define Flash hspi1

//Private Function prototype
uint8_t Read_Status_Register(uint8_t SR);
void Write_Status_Register(uint8_t SR, uint8_t REG_DATA);
void Write_Data_Buffer(uint16_t Buffer_Addr, uint8_t *Data, uint16_t len);
void Write_Data_Flash(uint16_t Page_Addr);
void Select_Page_Read(uint16_t Page_Addr);
void Read_Data_Buffer(uint8_t *Data, uint16_t len);
void Block_Erase(uint16_t Page_Addr);

//pointer
uint8_t* Buffer_p=&write_data_0[0];

//SPI Buffer for Tx and Rx
uint8_t Tx_Buffer[5]={0};
uint8_t Rx_Buffer[5]={0};

//Register constants
uint8_t OP_Read_Register = 0x0F;
uint8_t OP_Write_Register = 0x1F;

//OPCODE FOR FLASH
uint8_t OP_Dev_Res = 0xFF;
uint8_t OP_JEDEC_ID[2] = {0x9F, 0x00};
uint8_t OP_Write_Enable = 0x06;
uint8_t OP_Write_Disable = 0x04;
uint8_t OP_Block_Erase = 0xD8;
uint8_t OP_Load_Program_Data = 0x02;
uint8_t OP_Program_Ex = 0x10;
uint8_t OP_Page_Data_Read = 0x13;
uint8_t OP_Read_Data = 0x03;
uint8_t OP_Fast_Read = 0x0B;

///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////User friendly code for implementation///////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////


//Initialize flash IC
//BUF=1-> Buffer Read
//BUF=0-> Continuous Read
void Flash_Init(uint8_t BUF){
	HAL_Delay(1000);
	if(BUF){
		uint8_t data = Read_Status_Register(SR_2_Addr);
		data|=0x08;
		Write_Status_Register(SR_2_Addr, data);
	}
	else{
		uint8_t data = Read_Status_Register(SR_2_Addr);
		data&=0xF7;
		Write_Status_Register(SR_2_Addr, data);
	}
	uint8_t data = Read_Status_Register(SR_1_Addr);
	data|=0x02;
	data&=0x83;
	Write_Status_Register(SR_1_Addr, data);
}

//Read all status registers
void Read_Register(void){
	SR_1 = Read_Status_Register(SR_1_Addr);
	delay_ns(DELAY_NS);
	SR_2 = Read_Status_Register(SR_2_Addr);
	delay_ns(DELAY_NS);
	SR_3 = Read_Status_Register(SR_3_Addr);
	delay_ns(DELAY_NS);
}

//Write data to buffer in microcontroller
void Write_Data(uint8_t* data, uint16_t lenght){
	if((Page_Index==0)&&(Buffer_Index==0)){
		Block_Erase(0);
	}
	uint16_t count=0;
	while(count<lenght){
		*Buffer_p=*data;
		Buffer_p++;
		data++;
		Buffer_Index++;
		count++;
		if(Buffer_Index>=2048){
			Write_to_page();
		}
	}
}

//Write data to buffer in flash IC, then write buffer to page
void Write_to_page(void){
	if(Buffer_flip==0){
		Write_Data_Buffer(0, &write_data_0[0], Buffer_Index);
		Buffer_flip=1;
		memset(write_data_1, 0xFF, sizeof(write_data_1));
		Buffer_p=&write_data_1[0];
	}
	else{
		Write_Data_Buffer(0, &write_data_1[0], Buffer_Index);
		Buffer_flip=0;
		memset(write_data_0, 0xFF, sizeof(write_data_0));
		Buffer_p=&write_data_0[0];
	}
	Page_Index++;
	Buffer_Index=0;
	Automatic_Block_Managment(Page_Index);
}

//Read data from page and transfer to data
void Read_Data(uint16_t page, uint8_t* data){
	Select_Page_Read(page);
	Read_Data_Buffer(data, 2048);
}

//Check if page is located in new block. If it is located in new block, erase block
void Automatic_Block_Managment(uint16_t Page_Index){
	uint16_t Block=Page_Index/64;
	if(!(Block_Mem==Block)){
		Block_Erase(Page_Index);
		Block_Mem=Block;
	}
	else{
		Block_Mem=Block;
	}
}

//Erase all flash memory on IC
void Chip_Erase(void){
	uint8_t UART_buffer;
	USART1_Printf("Vil du slette alt minne for lagra flydata? Y/N\r\n");
	HAL_UART_Receive(&hcom_uart[COM1], &UART_buffer,1, HAL_MAX_DELAY);
	if(UART_buffer == 0x59){
		USART1_Printf("Sletter minne...\r\n");
		for(int i = 0; i <= 1024; i++){
			Block_Erase(i*64);
		}
		Buffer_Index=0;
		Page_Index=0;
		Block_Mem=0;
		Buffer_flip=0;
		Buffer_p=&write_data_0[0];
		memset(write_data_0, 0xFF, sizeof(write_data_0));
		memset(write_data_1, 0xFF, sizeof(write_data_1));
		USART1_Printf("Ferdig\r\n");
	}
	else{
		USART1_Printf("Sletter IKKE minne\r\n");
	}
}

//Read data continuous from IC, then print data to Virtual USART
void Read_Data_Cont(uint16_t len){
	Select_Page_Read(0);
	uint8_t Data_Buffer[len];

	Tx_Buffer[0]=OP_Read_Data;
	Tx_Buffer[1]=0x00;
	Tx_Buffer[2]=0x00;
	Tx_Buffer[3]=0x00;
	csLOW();

	HAL_SPI_Transmit(&Flash, &Tx_Buffer[0],4,100);
	HAL_SPI_Receive(&Flash, Data_Buffer, len, HAL_MAX_DELAY);

	uint16_t CAN_Temp = *(uint16_t*)&Data_Buffer[1];
	uint32_t Data_Temp = *(uint32_t*)&Data_Buffer[3];
	uint32_t Time_Temp = *(uint32_t*)&Data_Buffer[11];

	while((Data_Buffer[0]==0xFF)&&(Data_Buffer[15]==0x00)){
		USART1_Printf("CANID:%u, DATA:%u, Time:%u\r\n", (unsigned int)CAN_Temp, (unsigned int)Data_Temp, (unsigned int)Time_Temp);
		HAL_SPI_Receive(&Flash, Data_Buffer, len, HAL_MAX_DELAY);

		CAN_Temp = *(uint16_t*)&Data_Buffer[1];
		Data_Temp = *(uint32_t*)&Data_Buffer[3];
		Time_Temp = *(uint32_t*)&Data_Buffer[11];
	}
	csHIGH();
}


///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
////////Barebone code for interfacing with Flash IC////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////

//Enable WEL(Write enable latch) in flash IC
void Write_Enable(void){
	csLOW();
	HAL_SPI_Transmit(&Flash, &OP_Write_Enable, 1, 100);
	csHIGH();
	delay_ns(DELAY_NS);
}

//Disable WEL(Write enable latch) in flash IC
void Write_Disable(void){
	csLOW();
	HAL_SPI_Transmit(&Flash, &OP_Write_Disable, 1, 100);
	csHIGH();
	delay_ns(DELAY_NS);
}

//Read status register.
//SR->Select register address to read
uint8_t Read_Status_Register(uint8_t SR){
	Tx_Buffer[0]=OP_Read_Register;
	Tx_Buffer[1]=SR;
	csLOW();
	HAL_SPI_Transmit(&Flash, &Tx_Buffer[0], 2, 100);
	HAL_SPI_Receive(&Flash, &Rx_Buffer[0], 1, 100);
	csHIGH();
	return Rx_Buffer[0];
}

//Write to status register
//SR->register address to write
//REG_DATA->Register data to write to register
void Write_Status_Register(uint8_t SR, uint8_t REG_DATA){
	Tx_Buffer[0]=OP_Write_Register;
	Tx_Buffer[1]=SR;
	Tx_Buffer[2]=REG_DATA;
	csLOW();
	HAL_SPI_Transmit(&Flash, &Tx_Buffer[0], 3, 100);
	csHIGH();
}

//Read JEDEC ID from flash IC. Useful to check that Flash IC is connected correctly
uint32_t Read_ID(void){
	uint8_t Buffer[3]={0};
	csLOW();
	HAL_SPI_Transmit(&Flash, &OP_JEDEC_ID[0], 2, 100);
	HAL_SPI_Receive(&Flash, &Buffer[0], 3, 100);
	csHIGH();
	return ((Buffer[0]<<16)|(Buffer[1]<<8|Buffer[2]));
}

//Write data to buffer in flash IC
void Write_Data_Buffer(uint16_t Buffer_Addr, uint8_t *Data, uint16_t len){
	Write_Enable();
	Tx_Buffer[0]=OP_Load_Program_Data;
	Tx_Buffer[1]=(uint8_t)(Buffer_Addr>>8);
	Tx_Buffer[2]=(uint8_t)Buffer_Addr;
	csLOW();
	HAL_SPI_Transmit(&Flash, &Tx_Buffer[0], 3, 100);
//	HAL_SPI_Transmit_DMA(&Flash, Data, len);
//	SPI_DMA=1;
	HAL_SPI_Transmit(&Flash, Data, len, HAL_MAX_DELAY);
	csHIGH();
}

//Write buffer data to page
void Write_Data_Flash(uint16_t Page_Addr){
	Tx_Buffer[0]=OP_Program_Ex;
	Tx_Buffer[1]=0x00;
	Tx_Buffer[2]=(uint8_t)(Page_Addr>>8);
	Tx_Buffer[3]=(uint8_t)(Page_Addr);
	csLOW();
	HAL_SPI_Transmit(&Flash, &Tx_Buffer[0], 4, 100);
	csHIGH();
	W25N_WaitForReady();
}

//Select page to read
void Select_Page_Read(uint16_t Page_Addr){
	Tx_Buffer[0]=OP_Page_Data_Read;
	Tx_Buffer[1]=0x00;
	Tx_Buffer[2]=(uint8_t)(Page_Addr>>8);
	Tx_Buffer[3]=(uint8_t)(Page_Addr);
	csLOW();
	HAL_SPI_Transmit(&Flash, &Tx_Buffer[0],4,100);
	csHIGH();
	W25N_WaitForReady();
}

//Read data from selected page
//NB: Use Select_Page_Read to select page
void Read_Data_Buffer(uint8_t *Data, uint16_t len){
	Tx_Buffer[0]=OP_Read_Data;
	Tx_Buffer[1]=0x00;
	Tx_Buffer[2]=0x00;
	Tx_Buffer[3]=0x00;
	csLOW();
	HAL_SPI_Transmit(&Flash, &Tx_Buffer[0],4,100);
	HAL_SPI_Receive(&Flash, Data, len, HAL_MAX_DELAY);
	csHIGH();
}

//Erase Block where page is located
//Page_Addr-> Address to page, where the block which includes page is erased
void Block_Erase(uint16_t Page_Addr){
	Write_Enable();
	Tx_Buffer[0]=OP_Block_Erase;
	Tx_Buffer[1]=0x00;
	Tx_Buffer[2]=(uint8_t)(Page_Addr>>8);
	Tx_Buffer[3]=(uint8_t)(Page_Addr);
	csLOW();
	HAL_SPI_Transmit(&Flash, &Tx_Buffer[0], 4, 100);
	csHIGH();
	W25N_WaitForReady();
}
